# レビュー観点リファレンス

各サブエージェントのレビュー基準。SKILL.mdのStep 4でサブエージェントプロンプトに埋め込む。

---

## 1. Security Review

### チェック項目

**インジェクション**
- SQLインジェクション: 文字列連結によるクエリ構築、パラメータ化されていないクエリ
- NoSQLインジェクション: フィルタオブジェクトへの未検証入力
- コマンドインジェクション: シェルコマンド実行関数への未サニタイズ入力
- パストラバーサル: ユーザー入力によるファイルパス構築

**認証・認可**
- 認証チェックの欠落（コントローラー/ルートハンドラー）
- 認可バイパス（権限チェック不足、IDOR）
- セッション管理の問題（トークン有効期限、リフレッシュ処理）
- ハードコードされた認証情報
- マルチテナント: テナント分離の欠落（他テナントのデータへのアクセス可能性）

**データ漏洩**
- シークレット/APIキーのコード内ハードコード
- ログへの機密情報出力（パスワード、トークン、個人情報）
- エラーレスポンスでの内部情報露出（スタックトレース、DB構造）
- APIレスポンスでの不要なフィールド露出

**クライアントサイド**
- XSS（反射型、格納型、DOM型）: ユーザー入力の未エスケープ出力
- CSRF対策の欠如
- オープンリダイレクト
- 安全でないCookie設定（HttpOnly, Secure, SameSite）

**入力バリデーション**
- 未検証のユーザー入力がビジネスロジックに到達
- バリデーションのバイパス可能なパターン
- ファイルアップロードの検証不足（タイプ、サイズ、内容）
- 制御文字の検証漏れ（改行・タブ以外の制御文字を拒否すべき）

**依存関係**
- 既知のCVEがある依存関係の追加/更新
- セキュリティ上問題のあるライブラリの使用

---

## 2. Redundancy Review

### チェック項目

**デッドコード**
- 到達不能コード（return後のコード、常にtrue/falseの条件分岐）
- 使われていないメソッド/関数の追加
- コメントアウトされたコード（残すべきでない）

**重複ロジック**
- コピーペーストされたコードブロック（関数抽出すべき）
- 同じバリデーションロジックが複数箇所に（Value Objectに集約すべき）
- 似たクエリ/データ変換が繰り返し
- 同じドメインルールがDomain層とPresentation層に重複していないか

**不要なコード**
- 使われていないインポート/依存関係
- 不要な型アサーション/キャスト
- 冗長な条件チェック（フレームワークが保証する条件の再チェック等）
- 不要なnullチェック（non-nullable型に対するnullチェック等）

**過剰設計**
- 現時点で不要な抽象化（一箇所からしか使われないインターフェース等）
- 過剰なデザインパターンの適用
- 必要以上に複雑な設定/パラメータ化
- YAGNI原則に反するコード

---

## 3. Performance Review

### チェック項目

**データベース/クエリ**
- N+1クエリ問題（ループ内でのクエリ発行）
- インデックスのないカラムでの検索/ソート
- 不必要な全件取得（ページネーション欠如）
- 重いクエリのキャッシュ未活用
- 不要なJOINやサブクエリ
- 楽観ロックの欠落（同時更新が想定される操作）

**メモリ/アロケーション**
- 大量データの一括メモリ読み込み（ストリーミング/バッチ処理すべき）
- ループ内での不要なオブジェクト生成
- メモリリークのパターン（クローズされないリソース、削除されないリスナー）
- 大きなコレクションの不要なコピー

**非同期/並行処理**
- 非同期コンテキストでのブロッキング操作
- 並行実行可能な処理の逐次実行
- 不適切なスレッドプール/コルーチンディスパッチャーの使用
- デッドロックのリスク

**ネットワーク/I/O**
- 不要なAPI呼び出し（バッチ化可能）
- レスポンスペイロードが大きすぎる（不要なフィールド含む）
- 接続プーリングの未活用
- タイムアウト設定の欠如

**アルゴリズム**
- 明らかに非効率なアルゴリズム（O(n²) で O(n log n) が可能等）
- 不要なソート/フィルタの繰り返し

---

## 4. Requirements Alignment

### チェック項目

**要件カバレッジ**
- PR説明に記載された目的が実装に反映されているか
- リンクされたIssueの要件が全て満たされているか
- Issueの受入基準が全てカバーされているか
- 暗黙の要件の見落としがないか

**スコープ**
- 要件に含まれない変更がないか（スコープクリープ）
- 要件の一部が未実装ではないか
- 未ドキュメントの動作変更がないか

**エッジケース**
- 境界値の処理
- 空/null入力の処理
- 同時実行時の振る舞い
- エラー時のフォールバック

**後方互換性**
- APIの破壊的変更
- データベーススキーマ変更の影響（マイグレーションの有無）
- 設定ファイル形式の変更
- 既存クライアントへの影響

---

## 5. Framework Best Practices

### チェック項目

検出されたフレームワークに応じて、対応するチェックリストを参照:
- Kotlin/Spring → `references/kotlin-spring-checklist.md`
- TypeScript/Next.js → `references/typescript-nextjs-checklist.md`

**共通チェック項目**
- フレームワークの規約に従っているか
- 推奨されるパターン/アンチパターン
- フレームワーク提供の機能を活用しているか（車輪の再発明をしていないか）
- フレームワークバージョンに適したAPIを使用しているか（非推奨APIの使用）

**DDD/Clean Architecture（Kotlin/Spring検出時）**
- レイヤー依存方向の遵守（Domain層が外部レイヤーに依存していないか）
- 集約の整合性境界が適切か
- Value Objectによる型安全性（プリミティブ型の直接使用を避けているか）
- ドメインイベントの適切な発行と処理
- ユビキタス言語の一貫した使用

---

## 6. Error Handling & Resilience

### チェック項目

**例外処理**
- 例外の握りつぶし（空のcatchブロック）
- 広すぎるcatch（Exception/Throwableの一括catch）
- 不適切なエラー変換（元の原因情報の喪失）
- リソースの確実なクリーンアップ（try-with-resources, use, finally）
- ドメイン例外からHTTP例外への変換が網羅的か（Failure enumの全パターン処理）

**ログ・可観測性**
- エラー時のログ出力が適切か（レベル、メッセージ、コンテキスト）
- 構造化ログの活用
- トレーシング/相関IDの伝搬
- メトリクス収集ポイントの欠落

**リトライ・サーキットブレーカー**
- 外部サービス呼び出しのリトライ戦略
- 冪等性の考慮
- バックオフ戦略
- サーキットブレーカーパターンの必要性

**グレースフルデグラデーション**
- 外部サービス障害時のフォールバック
- タイムアウト設定
- デフォルト値の妥当性
- 部分的な障害への対応

---

## 7. Maintainability & Design

### チェック項目

**命名規則**
- 変数/関数/クラス名が意図を表現しているか
- 一貫した命名規則（キャメルケース/スネークケース等）
- 略語の乱用がないか
- ドメイン用語（ユビキタス言語）の一貫した使用

**責務分離**
- 単一責務原則（SRP）に従っているか
- 関数/メソッドが長すぎないか
- クラスが複数の責務を持っていないか
- レイヤー間の適切な分離（Presentation → Application → Domain ← Infrastructure）
- ビジネスロジックが適切なレイヤーに配置されているか（ControllerやInfrastructureにドメインロジックが漏れていないか）

**結合度・凝集度**
- 不要な依存関係の導入
- 循環依存
- インターフェース/抽象クラスによる適切な抽象化
- 変更の波及範囲が適切か
- 集約間の直接参照を避けIDで参照しているか

**テスト影響**
- テストが追加/更新されているか
- テストカバレッジの低下
- テスタビリティの低下（テスト困難なコードの導入）
- テストの品質（意味のあるアサーション、適切なモック）

**ドキュメント**
- パブリックAPI/インターフェースのドキュメント
- 複雑なロジックのコメント
- 重大な設計判断の記録
- DBマイグレーションファイルが必要な変更にマイグレーションが含まれているか
